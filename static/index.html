<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>DeutschCoach</title>
<style>
body { font-family: sans-serif; max-width: 600px; margin: 40px auto; }
button { width: 100%; padding: 16px; margin: 8px 0; font-size: 18px; }
.box { border: 1px solid #ccc; padding: 12px; margin-top: 10px; border-radius: 8px; }
#talkBtn { touch-action: none; }
</style>
</head>
<body>

<h1>DeutschCoach (Ã–sterreich)</h1>

<button id="talkBtn">ðŸŽ¤ Hold to talk</button>
<button id="resetBtn">ðŸ”„ Reset Conversation</button>

<div class="box">
<b>Mic status</b>
<div id="micStatus">â€”</div>
</div>

<div class="box">
<b>You said</b>
<div id="transcript">â€”</div>
</div>

<div class="box">
<b>Coach</b>
<div id="reply">â€”</div>
</div>

<audio id="player" controls></audio>

<script>
let mediaRecorder;
let chunks = [];
let sessionId = localStorage.getItem("sessionId") || "";

const talkBtn = document.getElementById("talkBtn");
const resetBtn = document.getElementById("resetBtn");
const transcriptEl = document.getElementById("transcript");
const replyEl = document.getElementById("reply");
const micStatusEl = document.getElementById("micStatus");
const player = document.getElementById("player");

async function startRecording() {
  micStatusEl.textContent = "Requesting microphoneâ€¦";
  transcriptEl.textContent = "Listeningâ€¦";
  replyEl.textContent = "â€”";
  chunks = [];

  let stream;
  try {
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch (err) {
    micStatusEl.textContent = `âŒ Mic blocked: ${err.name}`;
    throw err;
  }

  const candidates = ["audio/webm;codecs=opus","audio/webm","audio/mp4"];
  let chosen = "";
  for (const t of candidates) {
    if (window.MediaRecorder && MediaRecorder.isTypeSupported(t)) {
      chosen = t;
      break;
    }
  }

  if (!window.MediaRecorder) {
    micStatusEl.textContent = "âŒ MediaRecorder not supported on this iOS.";
    throw new Error("MediaRecorderNotAvailable");
  }

  mediaRecorder = chosen ? new MediaRecorder(stream, { mimeType: chosen }) : new MediaRecorder(stream);
  mediaRecorder.ondataavailable = (e) => {
    if (e.data.size > 0) chunks.push(e.data);
  };
  mediaRecorder.start();
  micStatusEl.textContent = "âœ… Recordingâ€¦";
}

async function stopRecording() {
  if (!mediaRecorder) return;
  return new Promise(resolve => {
    mediaRecorder.onstop = resolve;
    mediaRecorder.stop();
  });
}

async function sendToServer(blob) {
  transcriptEl.textContent = "Sendingâ€¦";

  const fd = new FormData();
  const ext = blob.type.includes("mp4") ? "mp4" : "webm";
  fd.append("audio", blob, `speech.${ext}`);
  fd.append("mode", "chat");
  fd.append("session_id", sessionId);

  const res = await fetch("/talk", { method: "POST", body: fd });
  const data = await res.json();

  if (data.session_id) {
    sessionId = data.session_id;
    localStorage.setItem("sessionId", sessionId);
  }

  transcriptEl.textContent = data.transcript;
  replyEl.textContent = data.reply;

  if (data.audio_b64) {
    player.src = "data:audio/mp3;base64," + data.audio_b64;
  }
}

talkBtn.addEventListener("touchstart", async (e) => {
  e.preventDefault();
  try {
    await startRecording();
  } catch {}
});

talkBtn.addEventListener("touchend", async (e) => {
  e.preventDefault();
  await stopRecording();
  if (!chunks.length) return;
  const blob = new Blob(chunks, { type: mediaRecorder.mimeType });
  await sendToServer(blob);
});

resetBtn.addEventListener("click", async () => {
  await fetch("/reset", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ session_id: sessionId })
  });
  sessionId = "";
  localStorage.removeItem("sessionId");
  transcriptEl.textContent = "â€”";
  replyEl.textContent = "Conversation reset.";
  player.src = "";
});
</script>

</body>
</html>
