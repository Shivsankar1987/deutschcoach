<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>DeutschCoach (Ã–sterreich)</title>

  <style>
    :root { color-scheme: light; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      padding: 18px;
      padding-bottom: calc(18px + env(safe-area-inset-bottom));
      background: #fff;
    }

    .container {
      max-width: 640px;
      margin: 0 auto;
    }

    h1 {
      font-size: 28px;
      margin: 10px 0 14px;
    }

    .row { margin: 10px 0; }

    button, select {
      width: 100%;
      font-size: 18px;
      padding: 14px;
      border-radius: 12px;
      border: 1px solid #ddd;
      background: #f4f4f4;
    }

    button:active { transform: scale(0.99); }

    .box {
      border: 1px solid #ddd;
      padding: 12px;
      margin-top: 10px;
      border-radius: 12px;
      background: #fff;
    }

    .label {
      font-weight: 700;
      margin-bottom: 6px;
    }

    #talkBtn { touch-action: none; }

    audio { width: 100%; margin-top: 10px; }
    .small { opacity: 0.65; font-size: 12px; margin-top: 6px; }
  </style>
</head>

<body>
  <div class="container">
    <h1>DeutschCoach (Ã–sterreich)</h1>

    <div class="row">
      <label class="label" for="mode">Mode</label>
      <select id="mode">
        <option value="chat">ğŸ—£ Chat</option>
        <option value="correct">âœï¸ Correct my sentence</option>
        <option value="roleplay">ğŸ­ Roleplay (BÃ¤ckerei/Schule)</option>
        <option value="quiz">ğŸ§  Mini quiz</option>
      </select>
      <div class="small">Tipp: FÃ¼r iPhone/iPad bitte in Safari Ã¶ffnen.</div>
    </div>

    <div class="row">
      <button id="talkBtn">ğŸ¤ Hold to talk</button>
      <button id="resetBtn">ğŸ”„ Reset Conversation</button>
    </div>

    <div class="box">
      <div class="label">Mic status</div>
      <div id="micStatus">â€”</div>
    </div>

    <div class="box">
      <div class="label">You said</div>
      <div id="transcript">â€”</div>
    </div>

    <div class="box">
      <div class="label">Coach</div>
      <div id="reply">â€”</div>
    </div>

    <audio id="player" controls></audio>

    <script>
      let mediaRecorder = null;
      let chunks = [];
      let isRecording = false;

      let sessionId = localStorage.getItem("sessionId") || "";

      const talkBtn = document.getElementById("talkBtn");
      const resetBtn = document.getElementById("resetBtn");
      const modeEl = document.getElementById("mode");

      const micStatusEl = document.getElementById("micStatus");
      const transcriptEl = document.getElementById("transcript");
      const replyEl = document.getElementById("reply");
      const player = document.getElementById("player");

      async function startRecording() {
        micStatusEl.textContent = "Requesting microphoneâ€¦";
        transcriptEl.textContent = "Listeningâ€¦";
        replyEl.textContent = "â€”";
        chunks = [];

        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (err) {
          micStatusEl.textContent = `âŒ Mic blocked: ${err.name} â€” ${err.message || ""}`;
          throw err;
        }

        if (!window.MediaRecorder) {
          micStatusEl.textContent = "âŒ MediaRecorder not supported on this device.";
          throw new Error("MediaRecorderNotAvailable");
        }

        // Choose best supported mime type (iOS can be picky)
        const candidates = [
          "audio/webm;codecs=opus",
          "audio/webm",
          "audio/mp4",
          "audio/aac"
        ];
        let chosen = "";
        for (const t of candidates) {
          if (MediaRecorder.isTypeSupported(t)) { chosen = t; break; }
        }

        mediaRecorder = chosen ? new MediaRecorder(stream, { mimeType: chosen }) : new MediaRecorder(stream);

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        mediaRecorder.onerror = (e) => {
          micStatusEl.textContent = `âŒ Recorder error: ${e.error?.name || "unknown"}`;
        };

        mediaRecorder.start();
        micStatusEl.textContent = "âœ… Recordingâ€¦";
      }

      async function stopRecording() {
        if (!mediaRecorder) return;
        return new Promise((resolve) => {
          mediaRecorder.onstop = () => resolve();
          mediaRecorder.stop();
        });
      }

      async function sendToServer(blob) {
        transcriptEl.textContent = "Sendingâ€¦";

        const fd = new FormData();

        // pick filename extension based on blob type
        const mime = blob.type || "";
        let ext = "webm";
        if (mime.includes("mp4")) ext = "mp4";
        else if (mime.includes("ogg")) ext = "ogg";
        else if (mime.includes("wav")) ext = "wav";
        else if (mime.includes("mpeg")) ext = "mp3";

        fd.append("audio", blob, `speech.${ext}`);
        fd.append("mode", modeEl.value);
        fd.append("session_id", sessionId);

        // timeout so UI doesn't hang forever
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), 45000);

        try {
          const res = await fetch("/talk", {
            method: "POST",
            body: fd,
            signal: controller.signal
          });

          if (!res.ok) {
            const text = await res.text();
            transcriptEl.textContent = `Server error (${res.status})`;
            replyEl.textContent = text.slice(0, 400);
            micStatusEl.textContent = "âŒ Send failed (server)";
            return;
          }

          const data = await res.json();

          if (data.session_id) {
            sessionId = data.session_id;
            localStorage.setItem("sessionId", sessionId);
          }

          transcriptEl.textContent = data.transcript || "â€”";
          replyEl.textContent = data.reply || "â€”";

          if (data.audio_b64) {
            player.src = "data:audio/mp3;base64," + data.audio_b64;
            // Try autoplay (may be blocked on iOS; manual play still works)
            try { await player.play(); } catch {}
          }

          micStatusEl.textContent = "âœ… Done";
        } catch (err) {
          micStatusEl.textContent = "âŒ Send failed";
          replyEl.textContent =
            err.name === "AbortError"
              ? "Timed out waiting for server."
              : (err.message || String(err));
        } finally {
          clearTimeout(t);
        }
      }

      // Unified hold-to-talk (works on Windows + iOS)
      talkBtn.addEventListener("pointerdown", async (e) => {
        e.preventDefault();
        if (isRecording) return;

        try {
          await startRecording();
          isRecording = true;
          talkBtn.textContent = "âºï¸ Recordingâ€¦ release to send";
        } catch (err) {
          replyEl.textContent = "Mic start failed (see Mic status).";
        }
      });

      async function finishRecording(e) {
        e.preventDefault();
        if (!isRecording) return;

        await stopRecording();
        isRecording = false;
        talkBtn.textContent = "ğŸ¤ Hold to talk";

        if (!chunks.length) {
          transcriptEl.textContent = "No audio captured. Try again.";
          micStatusEl.textContent = "âŒ No audio";
          return;
        }

        const blob = new Blob(chunks, { type: (mediaRecorder && mediaRecorder.mimeType) || "audio/webm" });
        await sendToServer(blob);
      }

      talkBtn.addEventListener("pointerup", finishRecording);
      talkBtn.addEventListener("pointercancel", finishRecording);

      // Reset conversation (server + browser)
      resetBtn.addEventListener("click", async () => {
        try {
          await fetch("/reset", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ session_id: sessionId })
          });
        } catch {}

        sessionId = "";
        localStorage.removeItem("sessionId");
        transcriptEl.textContent = "â€”";
        replyEl.textContent = "Conversation reset. Sag: â€Hallo!â€œ ğŸ™‚";
        micStatusEl.textContent = "â€”";
        player.src = "";
      });
    </script>
  </div>
</body>
</html>
